<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Audio Oscilloscope: Mic + Tone + Files</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: #0b0f14;
      color: #e6edf3;
      min-height: 100vh;
      display: grid;
      place-items: center;
    }
    .wrap {
      width: min(1100px, 92vw);
      background: #0f1620;
      border: 1px solid #1f2a37;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; }
    p { margin: 0 0 14px; font-size: 13px; color: #9fb0c0; line-height: 1.35; }
    canvas {
      width: 100%;
      height: 340px;
      display: block;
      border-radius: 12px;
      background: #071018;
    }
    .row {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
      margin-top: 14px;
    }
    @media (min-width: 950px) {
      .row { grid-template-columns: 1fr; }
    }
    .panel {
      background: #0b121b;
      border: 1px solid #1f2a37;
      border-radius: 12px;
      padding: 12px;
    }
    .controls { display: grid; gap: 10px; }
    .btns { display: flex; gap: 10px; align-items: center; }
    .btn-row { display:flex; justify-content:flex-start; gap:10px; align-items:center; }
    .tone-controls { display:flex; gap:12px; align-items:center; }
    .tone-controls > label { margin: 0; }
    button {
      appearance: none;
      border: 1px solid #2b3a4e;
      background: #111b28;
      color: #e6edf3;
      padding: 10px 12px;
      border-radius: 10px;
      font-weight: 650;
      cursor: pointer;
    }
    button.primary { border-color: #3b82f6; }
    button.warn { border-color: #f59e0b; }
    button:disabled { opacity: .45; cursor: not-allowed; }
    label {
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: #9fb0c0;
    }
    input[type="range"] { width: 100%; }
    input[type="number"], select, input[type="file"] {
      width: 100%;
      background: #0f1620;
      color: #e6edf3;
      border: 1px solid #2b3a4e;
      border-radius: 10px;
      padding: 8px 10px;
      box-sizing: border-box;
    }
    .grid2 { display: grid; gap: 10px; grid-template-columns: 1fr 1fr; }
    .stat { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; color: #c5d1de; }
    .hint { font-size: 12px; color: #8aa0b5; line-height: 1.35; }
    .tiny { font-size: 11px; color: #7f93a8; }
    .hr { height: 1px; background: #1f2a37; margin: 8px 0; }

    /* New / adjusted styles for inline file input + play button */
    .file-row { display:flex; gap:10px; align-items:center; width:100%; }
    .file-input-label { flex:1; min-width:0; } /* min-width:0 to allow flex child to shrink properly */
    .file-input-label input[type="file"] { width:100%; }
    .file-action-btns { display:flex; gap:8px; align-items:center; }
    .bottom-actions { display:flex; justify-content:flex-end; gap:10px; margin-top:8px; }
    .small-note { font-size:12px; color:#9fb0c0; }
    .status-row { display:flex; gap:12px; align-items:center; justify-content:flex-start; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Oscilloscope: Microphone + Tone Generator + Audio Files</h1>
    <p>
      Start the microphone to see your voice waveform. Start a tone (sine/square) to hear and see test signals.
      Load an audio file to play it through the same scope. (Mic requires HTTPS or localhost.)
    </p>

    <canvas id="scope" aria-label="oscilloscope"></canvas>

    <div class="row">
      <div class="panel">
        <div class="controls">

          <!-- Status / level moved into main panel (sidebar removed) -->
          <div class="status-row">
            <div class="stat" id="status">Status: idle</div>
            <div class="stat" id="level">Level: —</div>
          </div>

          <!-- Row 1: Mic controls -->
          <div class="btn-row">
            <div class="btns">
              <button id="startMicBtn" class="primary">Start Mic</button>
              <button id="stopMicBtn" disabled>Stop Mic</button>
            </div>
          </div>

          <!-- Row 2: Tone controls with tone settings to the left -->
          <div class="btn-row">
            <div class="tone-controls">
              <label style="min-width:220px;">
                Tone waveform
                <select id="waveType">
                  <option value="sine">Sine</option>
                  <option value="square">Square</option>
                </select>
              </label>

              <label style="width:180px;">
                Tone frequency (Hz)
                <input id="freq" type="number" min="20" max="20000" step="1" value="440" />
                <div class="stat"><span id="freqVal">440</span> Hz</div>
              </label>

              <div class="btns" style="margin-left:8px;">
                <button id="startToneBtn" class="warn">Start Tone</button>
                <button id="stopToneBtn" disabled>Stop Tone</button>
              </div>
            </div>
          </div>

          <!-- Row 3: File chooser + Play File to the right -->
          <div class="btn-row">
            <div class="file-row" style="width:100%;">
              <label class="file-input-label">
                Choose audio file (mp3/wav/aac/etc.)
                <input id="audioFile" type="file" accept="audio/*" />
              </label>

              <div class="file-action-btns">
                <button id="playFileBtn">Play File</button>
                <button id="stopFileBtn" disabled>Stop File</button>
              </div>
            </div>
          </div>

          <div class="hr"></div>

          <!-- Note: Tone/File volume controls removed per request -->

          <!-- Optional tiny note area (kept minimal) -->
          <div class="small-note">Use the controls above to start/stop mic, tone, and play files.</div>

          <!-- Stop All moved to the bottom -->
          <div class="bottom-actions">
            <div class="btns">
              <button id="stopAllBtn">Stop All</button>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // Utility / DOM
    // -----------------------------
    const $ = (id) => document.getElementById(id);

    const canvas = $("scope");
    const ctx = canvas.getContext("2d");

    const startMicBtn = $("startMicBtn");
    const stopMicBtn  = $("stopMicBtn");
    const startToneBtn = $("startToneBtn");
    const stopToneBtn  = $("stopToneBtn");
    const playFileBtn  = $("playFileBtn");
    const stopFileBtn  = $("stopFileBtn");
    const stopAllBtn   = $("stopAllBtn");

    const waveTypeSel = $("waveType");
    const freqInput = $("freq");
    const audioFileInput = $("audioFile");

    // Status/level elements (moved into main panel)
    const statusEl = $("status");
    const levelEl = $("level");

    const freqVal = $("freqVal");

    function setStatus(text) { if (statusEl) statusEl.textContent = "Status: " + text; }

    // -----------------------------
    // HiDPI canvas
    // -----------------------------
    function resizeCanvasForHiDPI() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const w = Math.floor(rect.width * dpr);
      const h = Math.floor(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }
    window.addEventListener("resize", resizeCanvasForHiDPI);
    resizeCanvasForHiDPI();

    function drawGrid() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = "#071018";
      ctx.fillRect(0, 0, w, h);

      // grid
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      const vDiv = 10, hDiv = 8;
      for (let i = 1; i < vDiv; i++) {
        const x = (w * i) / vDiv;
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
      }
      for (let j = 1; j < hDiv; j++) {
        const y = (h * j) / hDiv;
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
      }

      // center line
      ctx.strokeStyle = "rgba(255,255,255,0.14)";
      ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();
    }

    function computeRMS(uint8) {
      let sumSq = 0;
      for (let i = 0; i < uint8.length; i++) {
        const v = (uint8[i] - 128) / 128;
        sumSq += v * v;
      }
      return Math.sqrt(sumSq / uint8.length);
    }

    // -----------------------------
    // Web Audio graph
    // -----------------------------
    let audioCtx = null;

    // Input nodes
    let micStream = null;
    let micSource = null;

    let oscNode = null;

    let fileSource = null;     // AudioBufferSourceNode (one-shot)
    let fileBuffer = null;     // decoded AudioBuffer

    // Per-source gains into mix
    let micGain = null;
    let toneGain = null;
    let fileGain = null;

    // Mix and output
    let mixBus = null;         // sums sources
    let monitorGain = null;    // goes to speakers

    // Analysers for scope selection
    let micAnalyser = null;
    let toneAnalyser = null;
    let fileAnalyser = null;
    let mixAnalyser = null;

    // Defaults
    const DEFAULT_SMOOTH = 0.15;
    const DEFAULT_GAIN = 1.8;
    const DEFAULT_OUT_VOL = 0.6;
    const DEFAULT_TONE_VOL = 0.25; // previously from UI
    const DEFAULT_FILE_VOL = 0.70; // previously from UI

    function ensureAudio() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return audioCtx;
    }

    function ensureGraph() {
      const ac = ensureAudio();

      if (!mixBus) {
        // gains
        micGain = ac.createGain();
        toneGain = ac.createGain();
        fileGain = ac.createGain();

        mixBus = ac.createGain();
        monitorGain = ac.createGain();

        // analysers
        micAnalyser = ac.createAnalyser();
        toneAnalyser = ac.createAnalyser();
        fileAnalyser = ac.createAnalyser();
        mixAnalyser = ac.createAnalyser();

        // analyser defaults
        const fftSize = 2048;
        [micAnalyser, toneAnalyser, fileAnalyser, mixAnalyser].forEach(a => {
          a.fftSize = fftSize;
          a.smoothingTimeConstant = DEFAULT_SMOOTH;
        });

        // Route each source: gain -> analyser AND gain -> mix
        micGain.connect(micAnalyser);
        micGain.connect(mixBus);

        toneGain.connect(toneAnalyser);
        toneGain.connect(mixBus);

        fileGain.connect(fileAnalyser);
        fileGain.connect(mixBus);

        // mix -> analyser (for scope) and -> speakers
        mixBus.connect(mixAnalyser);
        mixBus.connect(monitorGain);
        monitorGain.connect(ac.destination);

        // initial volumes (UI sliders removed so use defaults)
        toneGain.gain.value = DEFAULT_TONE_VOL;
        fileGain.gain.value = DEFAULT_FILE_VOL;
        monitorGain.gain.value = DEFAULT_OUT_VOL;

        applyMonitorMode();
      }
    }

    async function resumeAudio() {
      const ac = ensureAudio();
      if (ac.state === "suspended") await ac.resume();
    }

    function applyMonitorMode() {
      if (!monitorGain) return;
      // Use fixed default per-source volumes (sliders removed)
      monitorGain.gain.value = DEFAULT_OUT_VOL;
      if (toneGain) toneGain.gain.value = DEFAULT_TONE_VOL;
      if (fileGain) fileGain.gain.value = DEFAULT_FILE_VOL;
    }

    function clampFreq(f) {
      if (!Number.isFinite(f)) return 440;
      return Math.max(20, Math.min(20000, f));
    }

    // -----------------------------
    // Mic controls
    // -----------------------------
    async function startMic() {
      try {
        ensureGraph();
        await resumeAudio();
        setStatus("requesting microphone…");

        micStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: false,
            noiseSuppression: false,
            autoGainControl: false
          }
        });

        micSource = audioCtx.createMediaStreamSource(micStream);
        micSource.connect(micGain);

        startMicBtn.disabled = true;
        stopMicBtn.disabled = false;

        setStatus("mic running");
      } catch (err) {
        console.error(err);
        setStatus("mic error: " + (err?.message || err));
      }
    }

    function stopMic() {
      if (micSource) {
        try { micSource.disconnect(); } catch {}
        micSource = null;
      }
      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }
      startMicBtn.disabled = false;
      stopMicBtn.disabled = true;
      setStatus(currentRunningStatus());
    }

    // -----------------------------
    // Tone controls
    // -----------------------------
    async function startTone() {
      ensureGraph();
      await resumeAudio();

      if (oscNode) return;

      oscNode = audioCtx.createOscillator();
      oscNode.type = waveTypeSel.value;
      oscNode.frequency.value = clampFreq(parseFloat(freqInput.value));

      oscNode.connect(toneGain);
      oscNode.start();

      startToneBtn.disabled = true;
      stopToneBtn.disabled = false;

      setStatus(currentRunningStatus());
    }

    function stopTone() {
      if (!oscNode) return;
      try { oscNode.stop(); } catch {}
      try { oscNode.disconnect(); } catch {}
      oscNode = null;

      startToneBtn.disabled = false;
      stopToneBtn.disabled = true;

      setStatus(currentRunningStatus());
    }

    // -----------------------------
    // File playback
    // -----------------------------
    async function loadSelectedFile() {
      const files = audioFileInput.files;
      if (!files || files.length === 0) return null;

      ensureGraph();
      await resumeAudio();

      const file = files[0];
      const arrayBuffer = await file.arrayBuffer();

      // decodeAudioData can reject if format isn't supported
      fileBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      return fileBuffer;
    }

    async function playFile() {
      try {
        ensureGraph();
        await resumeAudio();

        if (!fileBuffer) {
          const b = await loadSelectedFile();
          if (!b) {
            setStatus("choose an audio file first");
            return;
          }
        }

        // AudioBufferSourceNode is one-shot; recreate each play
        stopFile();

        fileSource = audioCtx.createBufferSource();
        fileSource.buffer = fileBuffer;

        // Allow looping? (off by default)
        fileSource.loop = false;

        fileSource.connect(fileGain);
        fileSource.start();

        fileSource.onended = () => {
          // Only update if we didn't stop it manually
          if (fileSource) {
            stopFileBtn.disabled = true;
            fileSource = null;
            setStatus(currentRunningStatus());
          }
        };

        stopFileBtn.disabled = false;
        setStatus(currentRunningStatus());
      } catch (err) {
        console.error(err);
        setStatus("file error: " + (err?.message || err));
      }
    }

    function stopFile() {
      if (fileSource) {
        try { fileSource.stop(); } catch {}
        try { fileSource.disconnect(); } catch {}
        fileSource = null;
      }
      if (stopFileBtn) stopFileBtn.disabled = true;
      setStatus(currentRunningStatus());
    }

    // -----------------------------
    // Stop all
    // -----------------------------
    function stopAll() {
      stopFile();
      stopTone();
      stopMic();

      // also mute monitor
      if (monitorGain) monitorGain.gain.value = 0;

      if (levelEl) levelEl.textContent = "Level: —";
      drawGrid();
      setStatus("stopped");
    }

    function currentRunningStatus() {
      const parts = [];
      if (micStream) parts.push("mic");
      if (oscNode) parts.push("tone");
      if (fileSource) parts.push("file");
      if (parts.length === 0) return "idle";
      return parts.join(" + ") + " running";
    }

    // -----------------------------
    // Scope rendering
    // -----------------------------
    let rafId = null;
    let data = null;

    function activeAnalyser() {
      // scope input removed; always show mixed signal
      return mixAnalyser;
    }

    function render() {
      const analyser = activeAnalyser();

      drawGrid();

      if (!analyser) {
        rafId = requestAnimationFrame(render);
        return;
      }

      const n = analyser.fftSize;
      if (!data || data.length !== n) data = new Uint8Array(n);

      analyser.getByteTimeDomainData(data);

      const rms = computeRMS(data);
      if (levelEl) levelEl.textContent = "Level: " + rms.toFixed(3);

      const w = canvas.width, h = canvas.height;
      const gain = DEFAULT_GAIN;

      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(132,204,255,0.95)";
      ctx.beginPath();

      // show full analyser buffer
      const samplesToShow = n;
      const start = 0;

      for (let i = 0; i < samplesToShow; i++) {
        const idx = start + i;
        const x = (i / (samplesToShow - 1)) * w;
        const v = (data[idx] - 128) / 128;
        const y = (h / 2) - v * (h * 0.40) * gain;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      rafId = requestAnimationFrame(render);
    }

    // -----------------------------
    // UI sync
    // -----------------------------
    function syncUI() {
      const f = clampFreq(parseFloat(freqInput.value));
      freqInput.value = f;
      if (freqVal) freqVal.textContent = String(f);

      // Update oscillator live
      if (oscNode) {
        oscNode.type = waveTypeSel.value;
        oscNode.frequency.setValueAtTime(f, audioCtx.currentTime);
      }

      // Update gains (no sliders, apply defaults)
      if (toneGain && fileGain && monitorGain) {
        applyMonitorMode();
      }
    }

    // -----------------------------
    // Wire events
    // -----------------------------
    startMicBtn.addEventListener("click", startMic);
    stopMicBtn.addEventListener("click", stopMic);

    startToneBtn.addEventListener("click", startTone);
    stopToneBtn.addEventListener("click", stopTone);

    if (playFileBtn) playFileBtn.addEventListener("click", playFile);
    if (stopFileBtn) stopFileBtn.addEventListener("click", stopFile);

    stopAllBtn.addEventListener("click", stopAll);

    // If user selects a new file, clear previous buffer and stop playback
    audioFileInput.addEventListener("change", () => {
      fileBuffer = null;
      stopFile();
      setStatus(currentRunningStatus());
    });

    // Controls
    [ freqInput, waveTypeSel ].forEach(el => {
      el.addEventListener("input", syncUI);
      el.addEventListener("change", syncUI);
    });

    // Initial state + start render loop
    syncUI();
    drawGrid();
    cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(render);

    // Cleanup
    window.addEventListener("beforeunload", () => {
      try { stopAll(); } catch {}
    });
  </script>
</body>
</html>
